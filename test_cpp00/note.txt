>>>>>>>>>>>>>>>>>> calsse et instance <<<<<<<<<<<<<<<<<<
------------------hpp
class Sample
{
	public:

		Sample(void);
		~Sample(void);
};
------------------cpp
Sample::Sample(void){
	std::cout << "Constructor called" << std::endl;
	return ;
}
Sample::~Sample(void){
	std::cout << "destructor called" << std::endl;
	return ;
}

>>>>>>>>>>>>>>>>>> video namespaces <<<<<<<<<<<<<<<<<<
- :: operateur de resolution de porte (acceder a une valeur au sein d'un namespace)
- [namespace][::][variable]
		si variable global [][::][val]
namespace Example {
	int	gl_var = 5;
	int	f(void) {return 5};
}

>>>>>>>>>>>>>>>>>> video iostream <<<<<<<<<<<<<<<<<<
- std::cin >> buf
	--> je souhaite injecter le contenu de l'entree standard dans buf
- std::cout << "test" << std::endl << std::endl;
	--> je souhaite injecter dans sortie "test" \n \n
- https://cplusplus.com/reference/iostream/cin/

>>>>>>>>>>>>>>>>>> mbr attibute, mbr function <<<<<<<<<<<<<<<<<<
- attribue membre : variable d'une classe
- fonction membre : fonction d'une classe
- dans .hpp --> [return type] [f_name](param){}
- dans .cpp --> [return type] [Class::f_name](param){}
- par default, cpp passe toujours un paramettre a une fonction membre

>>>>>>>>>>>>>>>>>> this <<<<<<<<<<<<<<<<<<
- this: pointeur sur l'instance courante. Sample.test_var <=> this->test_var
	pointeur special d instance. A utiliser quand code une fonction membre (dans le .cpp)
- dans le cas de fonction membre : il y a toujours un parametre (cache) passe dans une fonction
	--> afin de pouvoir utiliser le pointeur this.

++ >>>>>>>>>>>>>>>>>> initialization list <<<<<<<<<<<<<<<<<<
- syntaxe particuliere d'initialisation
	--> Sample2::Sample2(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3){}  (dans .cpp)
	--> Sample2(int p1, double p2, float p3); (dans .hpp)
- declaration de la variable s2 dans main de test : Sample2 s2(1, 24, 4.2);

++ >>>>>>>>>>>>>>>>>> const <<<<<<<<<<<<<<<<<<
- const = tres important. Il faut travailler avec le plus de const possible. code robuste ++
	--> rendre une variable constante Sample::Sample(float const f) : pi(f){}
	--> void	bar(void) const; (.hpp)
		void	Sample::bar(void)const {} (.cpp)
		cette fonction membre ne modifiera jamais l'instance courante.
		(jamais de this->var = ) --> l'instance sera en readonly.

>>>>>>>>>>>>>>>>>> Visibility <<<<<<<<<<<<<<<<<<
- public vs private
	controler l'encapsulation des fonctions membres
- public : possible d'y acceder a l'interieur ET a l'exterieur de la classe.
- prive : invisible a l'exterieur de la classe (via la fonction main par example)
- bonne idee d'utiliser un _val pour signifier que le membre est prive

>>>>>>>>>>>>>>>>>> class vs struct <<<<<<<<<<<<<<<<<<
- struct = class. Fonctionne de la meme facon. Meme syntaxe
- petite difference :
- struct : scoop par default public.
- class : scoop par default prive.
il vaut mieux oublie de mettre une variable en public qu'en prive. Du coup il vaut mieux utiliser class

>>>>>>>>>>>>>>>>>> accessors <<<<<<<<<<<<<<<<<<
- convention de nommage getFoo, setFoo
	comme getFoo va acceder en lecture seul on met int getFoo(void) const;
- permet de jouer les intermediaires.
	si setFoo en public et _foo prive, on pourra utiliser setFoo pour modifier la valeur prive _foo dans le main.

>>>>>>>>>>>>>>>>>> comparisons <<<<<<<<<<<<<<<<<<
- comparaison physique vs comparaison structurelle;
- sample instance1(42);
- sample instance2(42);
- les deux instance sont physiquement different, mais ont le meme contenue
	avec == (double egal) et des & on verifie si les deux instance ont la meme address;(comparaison physique)
	avec instance1.compare(&instance2) == 0 on compare l'un des contenus de la structure.

>>>>>>>>>>>>>>>>>> attribues & fonction non-membre <<<<<<<<<<<<<<<<<<
- variable/fonction de class = non membre
	--> static	example static int _nbInst;
	--> impossible de faire appel a this dans une fonction non membre.
		on doit donc passer par les ::
	--> attribue non membre = non initialise dans constructeur.
		int	sample::_nbInst = 0; a initialiser dans .cpp.
- variable/fonction d'instance = membre

>>>>>>>>>>>>>>>>>> pointers to members <<<<<<<<<<<<<<<<<<
- nouveau operateurs : .* et ->*
- int	sample::*p = NULL;
	je declare un pointeur sur int qui pointera sur un membre de la classe sample
	je souhaite pointer sur une variable membre de la classe sample
- s1.*p = 21; (on precise que le pointeur ca pointer in int de l'instance s1)
	s1.*p = 21; je vais assigner la valeur 21 au contenu de la variable membre de l'instance s1 pointe par ptr;

- void (sample::*f)(void) const;
	je souhaite pointer sur une fonction membre de la classe sample qui ne prend pas d'argument et qui est const
- f = &Sample::bar

instancier = declarer;


>>>>>>>>>>>>>>>>>> polymorphisme ad-hoc <<<<<<<<<<<<<<<<<<
un meme nom de fonction peut prendre des parametre different.
posibilite de declarer plusieurs fonction de meme nom mais a parametre different.
	== fonction surchargees (ou surcharge)
	---> differente semantique

>>>>>>>>>>>>>>>>>> surcharge d'operateur <<<<<<<<<<<<<<<<<<
ajout de semantique
notation infixe : 1 + 1
notation prefixe : + 1 1  --> +(1, 1) --> notation proche d/une fonction(dite notation fonctionnelle)
notation postfixe : 1 1 +
surcharge doit obeir a certain regle pour ne pas faire nptk
>>>>>>>>>>>>>>>>>> forme canomique d'une class <<<<<<<<<<<<<<<<<<
bonne pratique.
- constructeur default
- constructeur copie (qui prend en parametre une instance de la classe en question pour en creeer une copie)
	constructeur prend une instance de la meme classe en paramettre;
	permet de copier une instance (une nouvelle instance est cree)
- operateur = pour pouvoir faire des assignations intra class
	permet de mettre a jour la valeur d'une instance deja cree.
- destructeur



en plus il est de bon ton d'ajouter
- accesseur sur valeur membre
- surcharge de redirection de flux de la valeur membre
- fontion membre permettant d/avoir une version version string pour afficher.


41.41.41.0
255.255.255.192
0 - 63

64 - 127





256 - 240 = 16
